package org.philmaster.boot.service;

import java.util.List;

import javax.annotation.PreDestroy;
import javax.enterprise.context.ApplicationScoped;
import javax.sql.DataSource;

import org.apache.cayenne.BaseContext;
import org.apache.cayenne.BaseDataObject;
import org.apache.cayenne.ObjectContext;
import org.apache.cayenne.configuration.server.ServerModule;
import org.apache.cayenne.configuration.server.ServerRuntime;
import org.apache.cayenne.exp.Expression;
import org.apache.cayenne.exp.ExpressionFactory;
import org.apache.cayenne.query.ObjectSelect;
import org.apache.cayenne.query.Ordering;
import org.apache.cayenne.query.SelectQuery;
import org.philmaster.boot.model.Account;
import org.philmaster.boot.model.Client;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Philmasteryeah
 * 
 *         This class uses the database scheme which is generated by the cayenne
 *         modeler.
 * 
 *         pure jdbc example: JdbcTemplate jdbcTemplate;
 *         jdbcTemplate.update("INSERT INTO car(brand)VALUES(?)", "Honda"));
 * 
 *         orm cayenne example: ObjectContext ctx = dbBean.getContext(); Cars
 *         car = ctx.newObject(Cars.class); car.setName("test car");
 *         ctx.commitChanges();
 *
 */
// Joshua Blochs enum singleton cool stuff
@ApplicationScoped
public enum DatabaseService {

	INSTANCE;

	final Logger logger = LoggerFactory.getLogger(DatabaseService.class);

	private static final String CAYENNE_CONFIG = "cayenne-project.xml";
	private static final String DEFAULT_CLIENT_NAME = "default";

	private static ServerRuntime runtime = ServerRuntime.builder()
			.addConfig(CAYENNE_CONFIG)
			.addModule(new ServerModule())
			.build();

	public DataSource getDataSource() {
		return runtime.getDataSource();
	}

	public static ObjectContext getContext() {
		System.err.println("get context");
		
		try {
			return BaseContext.getThreadObjectContext();
		} catch (Exception e) {
			System.err.println("new context");
			ObjectContext octx = runtime.newContext();
			BaseContext.bindThreadObjectContext(octx);
			return octx;
		}
	}

//	@PreDestroy
//	private void dispose() {
//		System.err.println("dispose runtime");
//		runtime.shutdown();
//	}
	///////

	public static Client fetchDefaultClient(ObjectContext context) {
		return fetchClientByName(context, DEFAULT_CLIENT_NAME);
	}

	public static Client fetchClientByName(ObjectContext context, String name) {
		if (name == null || "null".equals(name.trim()) || name.trim()
				.isEmpty())
			return fetchDefaultClient(context);
		return ObjectSelect.query(Client.class)
				.where(Client.NAME.eq(name))
				.selectOne(context);
	}

	public static Account fetchAccountByUsername(ObjectContext context, String username, Client client) {
		return fetchAccountByUsername(context, username, client != null ? client.getName() : null);
	}

	@SuppressWarnings("unchecked")
	public static Account fetchAccountByUsername(ObjectContext context, String username, String clientname) {

		SelectQuery<Account> query = new SelectQuery<>(Account.class);
		query.andQualifier(ExpressionFactory.matchExp("username", username));
		query.andQualifier(ExpressionFactory.matchExp("client.name", clientname));
		List<Account> accounts = context.performQuery(query);
		if (accounts == null || accounts.isEmpty()) {
			// log.warning(MessageFormat.format("account not found for query: {0}", query));
			return null;
		}
		if (accounts.size() > 1) {
			// log.warning(MessageFormat.format("multiple account found for query: {0}",
			// query));
			return null;
		}

		return accounts.get(0);
	}

	public static <T extends BaseDataObject> T createNew(ObjectContext context, Class<T> clazz) {
		return context.newObject(clazz);
	}

	public static <T extends BaseDataObject> List<T> fetchAll(ObjectContext context, Class<T> clazz) {
		return context.select(SelectQuery.query(clazz));
	}

	public static <T extends BaseDataObject> List<T> fetch(ObjectContext context, Class<T> clazz, Expression where) {
		return ObjectSelect.query(clazz)
				.where(where)
				.select(context);
	}

	public static <T extends BaseDataObject> List<T> fetch(ObjectContext context, Class<T> clazz, Expression where,
			Ordering order) {
		return ObjectSelect.query(clazz)
				.orderBy(order)
				.where(where)
				.select(context);
	}

}
